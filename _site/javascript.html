<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <!--
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  -->
  <title>JavaScript</title>

    <!-- Le styles -->
    <link href="../css/bootstrapx.css" rel="stylesheet">
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">
    <link href="../assets/googlecodeprettify/sons-of-obsidian.css" rel="stylesheet">
    <link href="../css/tkdocs.css" rel="stylesheet">

 </head>

<body>

<div id="top-navbar"></div>

<!-- Subhead
================================================== -->
<header class="jumbotron subhead" id="overview">
  <div class="container">
    <h1>JavaScript</h1>
    <p class="lead">JavaScriptの基礎  MDNで学習したことをまとめています</p>
  </div>
</header>

<div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="col-sm-2 col-md-2 bs-docs-sidebar">
        <ul class="nav nav-list bs-docs-sidenav" id="navbar">
          <li><a href="#function"><i class="glyphicon glyphicon-chevron-right"></i>Function</a></li>
          <li><a href="#conditional"><i class="glyphicon glyphicon-chevron-right"></i>Conditionals</a></li>
          <li><a href="#objects1"><i class="glyphicon glyphicon-chevron-right"></i>Objects Ⅰ</a></li>
          <li><a href="#objects2"><i class="glyphicon glyphicon-chevron-right"></i>Objects Ⅱ</a></li>
          <li><a href="#loops"><i class="glyphicon glyphicon-chevron-right"></i>Loops</a></li>
        </ul>
      </div>
      <div class="col-sm-10 col-md-10">


        <!-- Function
        ================================================== -->
        <section id="function">
          <div class="page-header">
            <h1>Function</h1>
          </div>

          <h3>関数の定義</h3>
          <div class="row">
          <div class="col-sm-5 col-md-5">
<pre>
var 関数名 = function(引数){
    // code  
    return 戻り値
};
</pre>
		  </div>
		  <div class="col-sm-5 col-md-5">
<pre>
//立方を求める関数 cube
var cube = function(x){
    // code  
    return x * x * x; 
};

cube(5);
</pre>
		  </div>
		  </div>  <!-- /row -->

			<hr class="bs-docs-separator">
			<h3>引数</h3>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>引数は複数とることができる。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var multiply = function (x, y) {
   return x * y;
};

multiply(2, 5);

var volume = function (w, l, h ) {
  return w * multiply(l,h);
};

volume(2, 3, 4);
</pre>
			</div>
			</div><!-- /row -->
			
			
			<hr class="bs-docs-separator">
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>引数の型を関数定義時に指定する必要はない。<br>
			但し、上記 cube関数のように数字を扱う引数に文字を与えると <code>cube("five")</code><br>
			<code>NaN</code>(not a number)がもどる。
			</p>
			<p>引数が正しい型でない場合でも、戻り値を数値にしたい時は、<br>
			<code>typeof(x)</code>で、引数の型チェックを行う。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var cube = function (x) {
   if (typeof(x) != 'number') return 0;
  return x * x * x;
};

cube("string");
</pre>
			</div>
			</div> <!-- /row -->
			
			
			<hr class="bs-docs-separator">

			<p>引数は関数内でのローカル変数である。</p>
<pre>
var w = 15;

var volume = function (w, l, h) {
   return w * l * h;
};

volume(2, 3, 4);
console.log(w); // 15
</pre>

			<p>関数内にローカル変数を追加するには</p>
<pre>
var volume = function (w, l, h) {
  var area = w * l; // ローカル変数定義
  return area * h;
};

 var area = 36;
console.log(volume(2, 3, 4)); // 24
console.log(area); // 36
</pre>

<pre>
var area = 36; //グローバル変数

var volume = function (w, l, h) {
  var area = w * l; //ローカル変数
  return area * h;
};

console.log(volume(2, 3, 4)); //24
console.log(area); // 36
</pre>
			<p>関数の外の変数<code>area</code>はグローバルで、
			プログラムのどこからでも参照できます。
			呼ばれた関数は、変数<code>area</code>をローカルとして扱います。
			</p>
        </section>


		<hr class="bs-docs-separator">

        <!-- Conditional
        ================================================== -->
        <section id="conditional">
          <div class="page-header">
            <h1>Conditionals</h1>
          </div>

			<p class="lead">
				条件式
			</p>

			<h3 class="text-info">if else 文</h3>
			<h4>if 文</h4>
			<div class="row">
<pre>
var yourName = "";
var result = "";
if (yourName.length===0) {
  result = "What is your name?";
}
</pre>
			</div> <!--/row-->

			<h4>条件に合うもの、合わないもの</h4>
			<div class="row">
<pre>
var yourName = "NIck";
var result =  "";
// use the > symbol to check the length of yourName
if (yourName.length > 0) {
   result = "Hi "+ yourName;
} else {
   result = "What is your name?";
}
</pre>
			</div> <!--/row-->

			<h4>複数の条件をテスト</h4>
			<div class="row">
<pre>
var yourName = "take";
var gender = "female";
var result;

if (gender==="male") {
  result = "His name is "+yourName;
} else if (gender==="female") {
  result = "Her name is "+yourName;
} else {
  result = "Hi "+yourName;
}
</pre>
			</div> <!--/row-->


			<h4>最低1つの条件を満たす</h4>
			<div class="row">
<pre>
var yourName = "Take";
var gender = "female";

// don't forget to use the || operator 
if (gender === "male" || gender === "female"   ) {
  result = true;
} else {
  result = false;
}
</pre>
			</div> <!--/row-->


			<h4>両方の条件を満たす</h4>
			<div class="row">
<pre>
var yourName = "Take";
var gender = "male";
var result;

if (yourName.length>0 && gender.length > 0) {
  result = "Thanks";
} else {
  result = "Please make sure both yourName and gender are filled in.";
}
</pre>
			</div> <!--/row-->


			<h4>条件文の入れ子</h4>
			<div class="row">
<pre>
var yourName = "Take";
var gender = "male";
var result;


if (yourName.length > 0 && gender.length > 0) {
  if (gender ==="male" || gender==="female") {
    result = "Thanks";
  } else {
    result = "Please enter male or female for gender.";
  }
} else {
  result = "Please tell us both your name and gender.";
}
</pre>
			</div> <!--/row-->


			<hr class="bs-docs-separator">
			<h3 class="text-info">switch 文</h3>
			<div class="row">
<pre>
var jacketColor = "green";
var result;

switch (jacketColor) {
    
  case "black":
    result = "Pay $300";
    break;
    
  case "brown":
    result = "Pay $200";  
    break;
    
  case "green":
    result = "Pay $5";
    break;
    
  default:
    result = "This color does not match my eyes!";
}
</pre>
			</div> <!--/row-->


			<hr class="bs-docs-separator">
			<h3 class="text-info">Ternary operators</h3>
			<div class="row">

			<p><code>result = x > y ? "good job" : 20;</code></p>
			<p>右辺の結果を左辺に代入する。</p>

			<div class="row">
				<div class="col-sm-5 col-md-3">
					<code>x > y ?</code><br>
					<code>"good job" : 20;</code>
				</div>
					<p>
					条件式<br>
					真の時<strong>:</strong>の左側の値が<code>result</code>へ代入される<br>
					負の時<strong>:</strong>の右側の値が<code>result</code>へ代入される
					</p>
			</div>

<pre>
var x = 2;
var y = 3;

if (x > y) {
  result = "good job";
}
else {
  result = 20;
}

//Below is the above code written using the ternary operator
result = x > y ? "good job" : 20;
</pre>
			</div> <!--/row-->


        </section>
		<hr class="bs-docs-separator">
        
        <!-- Objects
        ================================================== -->
        <section id="objects1">
          <div class="page-header">
            <h1>Objects</h1>
          </div>

			<p class="lead">
				オブジェクトというデータ型についての学習
			</p>
			
			<h3 class="text-info">オブジェクトとは何か？</h3>
			<p>オブジェクトは、現実世界の物や（人や銀行口座のような）実体を
			コードで表すことができ、関連のある情報を一まとめに保持しているもの。
			</p>
			<h4>オブジェクトを作るには</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>var</code> ＋ <code>オブジェクト名</code> ＋ <code>=</code> に </p>
			<p>
				<ol>
					<li>開始の<code>{</code></li>
					<li>ここに情報</li>
					<li>終了の<code>}</code></li>
				</ol>
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var Takeshi = {};//情報を持っていないオブジェクト
</pre>
			</div>
			</div> <!--/row-->

			<hr class="bs-docs-separator">
			<h3 class="text-info">Properties</h3>
			<h4>プロパティ</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトに含める各々の情報のことをプロパティと呼びます。</p>
			<p>プロパティには名前と値があります。<code>name : value</code></p>
			<p>Takeshiの年齢(age)は　40才ならば<code>age : 40</code></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var Spencer = {
  age: 22,
  country: "United States"
};

var Me = {
	age: 40,
	country: "Japan"
};
</pre>
			</div>
			</div> <!--/row-->


			<h4>プロパティにアクセスするには</h4>
			<h5>dot notation</h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>オブジェクト名</code>+<code>.</code>+<code>プロパティ名</code></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var myAge = Me.age;
var myCountry = Me.country;
</pre>
			</div>
			</div> <!--/row-->


			<h5>bracket notation</h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>オブジェクト名["プロパティ名"]</code></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var myAge = Me["age"];
var myCountry = Me["country"];
</pre>
			</div>
			</div> <!--/row-->

			<hr class="bs-docs-separator">
			<h3 class="text-info">Another way to create</h3>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>{ }</code>を使ってオブジェクトを作成する記法を
			<strong>literal notation</strong>といいます。</p>
			<p>もう一つは、キーワード<code>new</code>を使う方法で
			<strong>constructor</strong>を使いオブジェクトを作成する記法
			(<strong>constructor notation</strong>)として知られています。</p>
			</div>
			<div class="col-sm-5 col-md-5">
			</div>
			</div> <!--/row-->

			<div class="row">
			<div class="col-sm-5 col-md-5">
			<code>new</code>に続き<code>Object()</code>を記述し、空のオブジェクトを作ります。
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var objectName = new Object();
</pre>
			</div>
			</div> <!--/row-->

			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>この場合のプロパティの追加方法は</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
objectName.propertyName = value;
</pre>
<pre>
var bob = new Object();
bob.name = "Bob Smith";
bob.age = 30;

// literal notation
var susan1 = {
  name: "Susan Jordan",
  age: 24
};
// constructor notation
var susan2 = new Object();
susan2.name = "Susan Jordan";
susan2.age = 24;
</pre>
			</div>
			</div> <!--/row-->




			<hr class="bs-docs-separator">
			<h3 class="text-info">Methods</h3>
			<h4>メソッドとは？</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>プロパティがオブジェクトに関連した変数と考えられます。
			そして<strong>メソッド</strong>はオブジェクトに関連した関数と言えます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var bob = new Object();
bob.name = "Bob Smith";
bob.age = 30;
// method, setAge
bob.setAge = function (newAge){
  bob.age = newAge;
};
// bobの歳を20にセットする
bob.setAge(20);
</pre>
			</div>
			</div> <!--/row-->
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>メソッド<code>setAge</code>の定義は、プロパティの定義に似ています。
			大きな違いは、右辺に値ではなく関数を記述するところです。
			このメソッドは、与えられた引数で、プロパティ<code>bob.age</code>を設定します。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// method, setAge
bob.setAge = function (newAge){
  bob.age = newAge;
};
</pre>
			</div>
			</div> <!--/row-->

			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>メソッドの呼び出しは関数と同じようにします。</p>
			<code>ObjectName.methodName()</code>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// bobの歳を20にセットする
bob.setAge(20);
</pre>
			</div>
			</div> <!--/row-->


			<h4>メソッドが重要な訳</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<ol>
				<li>プロパティの値を変更できる。</li>
				<li>関数は与えられた引数を基に計算を行いますが、
				メソッドはオブジェクトのプロパティを基に計算ができる。</li>
			</ol>			
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var bob = new Object();
bob.age = 30;
// method, setAge
bob.setAge = function (newAge){
  bob.age = newAge;
};
// method getYearOfBirth 
bob.getYearOfBirth = function () {
  return 2012 - bob.age;//プロパティを使用
};
</pre>
			</div>
			</div> <!--/row-->


			<h5>キーワード <code>this</code></h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>今までの<code>setAge</code>は,<code>bob</code>にとって
			<code>bob.age</code>を変更してくれるのでいいものです。
			しかし、ほかの人にもこのメソッドを利用したい時にはどうすればよいでしょうか。</p>
			<p>新しいキーワード<code>this</code>を使い、多くのオブジェクトで
			メソッドが動作するようにします。
			<code>this</code>は、プレースホルダーの役をして、
			メソッドが実際に使われた時に、そのメソッドを呼び出したオブジェクトを指し示します。</p>
			<p><code>bob.setAge(50)</code>が呼ばれると
			メソッド<code>setAge</code>の中の<code>this</code>は
			オブジェクト<code>bob</code>を指しているので
			<code>this.age</code>は<code>bob.age</code>ということになります。
			これで他のオブジェクトでも、一度定義したメソッドを再使用し適用できます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// bobを作成する前に"this"を使ってメソッドを定義します
var setAge = function (newAge) {
  this.age = newAge;
};
// bobを作ります
var bob = new Object();

// bobのプロパティ aga を設定
bob.age = 30;

// すでに作ったメソッドで、bobのメソッドを設定します
bob.setAge = setAge;
  
// bobの age を　50に変えます（メソッドの実行）
bob.setAge(50);

// susanを作成し age を 25　にする
var susan = new Object();
susan.age = 25;
//定義済みメソッドを再使用しsusanに設定する
susan.setAge = setAge;
// Susanの age を 35 にする
susan.setAge(35);
</pre>
			</div>
			</div> <!--/row-->

			
			
			<h5>別種のメソッド</h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクト<code>square</code>を作ります。</p>
			<p>正方形の1辺の長さを表すプロパティ<code>sideLength</code>を追加します。</p>
			<p>周囲の長さを計算するメソッド<code>calcPerimeter</code>を追加します。
			このメソッドは関数と同じように<code>return</code>で戻り値を受け取れます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var square = new Object();
square.sideLength = 6;
square.calcPerimeter = function() {
  return this.sideLength * 4;
};
// help us define an area method here
square.calcArea = function() {
	return this.sideLength * this.sideLength; 	
};

var p = square.calcPerimeter();
</pre>
			</div>
			</div> <!--/row-->


			<hr class="bs-docs-separator">
			<h3 class="text-info">Constructor</h3>
			
			<h4>Object Constructor</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<code>bob = new Object( )</code>と書いた場合
			<span class="text-info"> Object </span>という組込みコンストラクタを使っています。
			このコンストラクタはJavaScript言語にすでに定義されていて、
			プロパティもメソッドないオブジェクトを作るだけです。</p>
			<p>これは、その都度プロパティを追加しなければいけないことを意味しています。</p>
			</div>
			<div class="col-sm-5 col-md-5">
			</div>
			</div> <!--/row-->


			<h4>Custom Constructors</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトごとに毎度毎度プロパティを追加するのは面倒なことです。
			そんな <span class="text-info">object</span> コンストラクタを使う代わりに
			プロパティを持った独自のコンストラクタを作ることができます。</p>
			</div>
			</div>
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>
				<code> Person </code>というコンストラクタは 
				<code> Person </code>オブジェクトを作るために使われます。
				またキーワード<span class="text-info"> this </span>を使って
				プロパティ<code> name </code>と<code> age </code>を定義し、
				与えられた引数の値にセットされます。
			</p>
			<p>このコンストラクタを使って<code> bob </code>と<code> susan </code>を作ります。
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
//独自のコンストラクタ
function Person(name,age) {
  this.name = name;
  this.age = age;
}

// 独自のコンストラクタを使って bob と susan を作ります
var bob = new Person("Bob Smith", 30);
var susan = new Person("Susan Jordan", 25);
</pre>
			</div>
			</div> <!--/row-->

			



			<h4>More options</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>すべてのプロパティを引数を使って定義する必要はありません。
			今度のコンストラクタ<code> Person </code>では、
			<code> species </code>が<span class="text-success"> "Homo Sapiens" </span>
			に設定されています。
			</p>
			<p>このことは、どの<code> Person </code>を作る時も
			<code> species </code>は<span class="text-success"> "Homo Sapiens" </span>
			になるということです。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(name,age) {
  this.name = name;
  this.age = age;
  this.species = "Homo Sapiens";
}

var sally = new Person("Sally Bowles",39);
var holden = new Person("Holden Caulfield",16);
</pre>
			</div>
			</div> <!--/row-->


			<h4>Constructors With Methods</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>コンストラクタにプロパティを設定できるのに加えて、
			メソッドを定義することもできます。つまり、オブジェクトを作成した段階で
			独自のメソッドも持っているということです。</p>
			<p>
			<code>Rectangle</code>コンストラクタにはプロパティ
			<code> length, width </code>があります。そして、
			<code> calcArea, calcPerimeter </code>メソッドがり、面積と周囲の長さを返します。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Rectangle(length, width) {
  // own properties
  this.length = length;
  this.width = width;

  //own methods
  this.calcArea = function() {
      return this.length * this.width;
  };
  this.calcPerimeter = function() {
    return this.length * 2 + this.width * 2;	
  };
}

var rex = new Rectangle(7,3);
var area = rex.calcArea();
var perimeter = rex.calcPerimeter();
</pre>
			</div>
			</div> <!--/row-->


			<hr class="bs-docs-separator">
			<h3 class="text-info">Combining Objects With Our Other Tools</h3>
			
			<h4>オブジェクトの配列</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトは数値型や文字列型と同じように1種の型です。
			なので、オブジェクトの配列を作ることができます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Person constructor
function Person (name, age) {
    this.name = name;
    this.age = age;
}

// an array of people : family
var family = new Array();
family[0] = new Person("alice", 40);
family[1] = new Person("bob", 42);
family[2] = new Person("michelle", 8);
family[3] = new Person("timmy",6);
</pre>
			</div>
			</div> <!--/row-->



			<h4>ループ</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>数値や文字列の配列と同様に、ループでオブジェクトの配列を使用できます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Person constructor
function Person (name, age) {
    this.name = name;
    this.age = age;
}

// an array of people : family
var family = new Array();
family[0] = new Person("alice", 40);
family[1] = new Person("bob", 42);
family[2] = new Person("michelle", 8);
family[3] = new Person("timmy",6);

for (i=0;i<4;i++) {
   console.log(family[i].name);
}
</pre>
			</div>
			</div> <!--/row-->

			

			<h4>オブジェクトを関数に渡す</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトを関数の引数にもできます。
			オブジェクトを受取った関数は、そのオブジェクトの
			プロパティやメソッドを使用できます。</p>
			<p>関数<code>ageDifference</code>はオブジェクトを受取ることで
			そのプロパティ<code> age </code>を使用し年齢差を計算します。
			文字列である名前を受け渡しても計算はできません。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Person constructor
function Person (name, age) {
    this.name = name;
    this.age = age;
}

// Personオブジェクトを引数にとる関数を作ります。
// この関数は２人の齢の差を計算します。
var ageDifference = function(person1, person2) {
    return person1.age - person2.age;
};

var alice = new Person("Alice", 30);
var billy = new Person("Billy", 25);

// alice と billy の年齢差を関数を使って取得します。
var diff = ageDifference(alice,billy);
</pre>
			</div>
			</div> <!--/row-->



        </section>

		<hr class="bs-docs-separator">
        <!-- Object Ⅱ
        ================================================== -->
        <section id="objects2">
          <div class="page-header">
            <h1>Object Ⅱ</h1>
          </div>

			<p class="lead">
				オブジェクトについてもっと勉強していきます
			</p>	
			
			<h3 class="text-info">オブジェクトはどこにでも</h3>
			
			<h5>IDを見せてください</h5>
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>さらにオブジェクトを勉強していく前に、それが数値型でも文字列型でもなく、
			オブジェクトだとどうしたらわかるのでしょう？いいものがあります</p>
			<p>型のわからない変数<code> thing </code>があります、そこで
			<span class="text-info"> typeof</span><code> thing </code>を呼ぶと、
			その型を知ることができます。
			最も利用する、"number", "string", "function", そして "object"。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var anObj = { job: "I'm an object!" };
var aNumber = 42;
var aString = "I'm a string!";

console.log( typeof anObj ); // print "object"
console.log( typeof aNumber ); // print "number"
console.log( typeof aString ); // print "string"
</pre>
			</div>
			</div> <!--/row-->

			<h5>汝自身を知る</h5>
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>JavaScriptのオブジェクトは、道具箱を持っています。
			その中には<code> hasOwnProperty </code>というメソッドが含まれています。
			このメソッドは、オブジェクトが特定のプロパティを持っているかを
			<code>true</code> か <code>false</code>で教えてくれます。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var myObj = {
    name:"Takeshi"
};

console.log( myObj.hasOwnProperty('name') ); 
                  // should print true
console.log( myObj.hasOwnProperty('nickname') ); 
                  // should print false
</pre>
<pre>
var suitcase = {
    shirt: "Hawaiian"
};
if (suitcase.hasOwnProperty('shorts')) {
	console.log(suitcase.shorts);
} else {
	suitcase.shorts = "boxer";
	console.log(suitcase.shorts);
}
</pre>
			</div>
			</div> <!--/row-->

			<h5>for - in loop</h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトに属するすべてのプロパティを扱います。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var dog = {
species: "bulldog",
age: 3,
color: brown
};
</pre>
			</div>
			</div> <!--/row-->
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクト<code> dog </code>のすべてのプロパティを簡単に一度で表示します。</p>
			<p><code>var</code>と<code>in </code>はキーワードです。この位置に必ず書きます。
			<code> dog </code>を別のオブジェクトに置き替えます。
			<code>property </code>は変数名で、別の名前で構いません。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
for(var property in dog) {
  console.log(property);
}
</pre>
			</div>
			</div> <!--/row-->


			<h5>プロパティの値を全部リストアップ</h5>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>for-in loopですべてのプロパティ名を取得できました。
			プロパティの値はどうでしょう？これもfor-in loopで取得できます。</p>
			<p>dog.species = dog["species"] = "bulldog" </p>
			<p>なので</p>
			<p>var x = "species"</p>
			<p>ならば</p>
			<p>dog[x] = "bulldog"</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var dog = {
species: "bulldog",
age: 3,
color: brown
};
</pre>
			</div>
			</div> <!--/row-->
			<div class="row">
			<div class="col-sm-5 col-md-5">

			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var nyc = {
    fullName: "New York City",
    mayor: "Michael Bloomberg",
    population: 8000000,
    boroughs: 5
};

/* write a for-in loop 
  to print the value of nyc's properties */
for (var property in nyc) {
    console.log(nyc[property]);
}
</pre>
			</div>
			</div> <!--/row-->

			<hr class="bs-docs-separator">
			<h3 class="text-info">OOPをやっつけろ？</h3>
			<p>Object Oriented Programmingの基礎</p>

			<h4>Class</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>コンストラクタを作成するとき、実は新しいクラスを定義しているのです。
			クラスは、ある種の型と考えられるし、または、オブジェクトのカテゴリとも
			考えられます(JavaScriptにおいて<code>Number</code> や <code>String</code>
			が型の種類であるように)。</p>
			<p><code>bob</code> と <code>susan</code> は、２つの別オブジェクトです。
			いかし両者は <code>Person</code> クラスに属しています。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(name,age) {
  this.name = name;
  this.age = age;
}

var bob = new Person("Bob Smith", 30);
var susan = new Person("Susan Jordan", 35);
</pre>
			</div>
			</div> <!--/row-->
			
			
			<h4>スヌーピーに教える</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>クラスは、プロパティとメソッドを持ちます、しかし、与えられたクラスが
			何ができて、何ができないのか、何を持っていて、何を持っていないのかを
			見ているものは何なのでしょう。
			この仕事をするのが <strong>prototype</strong>です。</p>

			<p>JavaScriptは、コンストラクタでもって自動的にクラスのためのプロトタイプを
			定義します。</p>
			<p><code>Dog</code> コンストラクタは、<code>Dog</code> プロトタイプに
			必ず <code>breed</code> プロパティを持たせます。</p>
			<p><code>buddy</code> にメソッド <code>bark</code>を追加します。
			<code>buddy</code>は吠えることができますが、
			<code>snoopy</code>は同じ<code>Dog</code>クラスですが吠えることはできません。
			<code>snoopy</code>にも吠え方を教えてあげなくてはいけません。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Dog (breed) {
  this.breed = breed;
}

// buddyを作成し、吠え方(bark)を教えます
var buddy = new Dog("Golden Retriever");
buddy.bark = function() {
  console.log("Woof");
};
buddy.bark();

// snoopyを作成します
var snoopy = new Dog("Beagle");

// snoopyに吠え方を教えていないので、エラーになります
snoopy.bark();

// snoopyに 吠え方を教えます
snoopy.bark = function() {
   console.log("Wow");
};
// snoopyは吠えます
snoopy.bark();

</pre>
			</div>
			</div> <!--/row-->


			<h4>クラスはどのように役に立つのか</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>クラスはoopでとても重要です。オブジェクトに関する有用な情報を、
			クラスは教えてくれるからです。オブジェクトはクラスの実体と考えられます。</p>
			<p>また<code>Person</code>クラスを見ましょう。どの<code>Person</code>にも
			<code>name</code> と <code>age</code> があります。
			それはコンストラクタにあるからです。
			このことは、<code>Person</code>を引数として受け取り、その名前を表示する
			<code>printPersonName</code>のような関数を作ることができます。
			この関数はどの<code>Person</code>に対しても動作します。
			なぜなら<code>name</code>はそのクラスの有効なプロパティだからです。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(name,age) {
  this.name = name;
  this.age = age;
}
// 引数Personの名前を表示する関数
function printPersonName(p) {
  console.log(p.name);
}

var bob = new Person("Bob Smith", 30);
printPersonName(bob);

var me = new Person("Takeshi Koyama", 54);
printPersonName(me);

</pre>
			</div>
			</div> <!--/row-->


			<h4>プロトタイプを応援！</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>また似たようなコードですが、重要な違いがあります。
			<code>buddy</code>オブジェクトに bark メソッドを追加するのに
			<code>buddy.bark</code>を使う代わりに<code>Dog.prototype.bark</code>
			を使っています。</p>
			<p>これは、<code>Dog</code>クラスのプロトタイプを変更したことになります。
			これで<code>buddy</code>も<code>snoopy</code>も吠えることができます。
			<strong>こうするとすべての<code>Dog</code>に、
			直ちに新しいメソッドを教えられます。</strong></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Dog (breed) {
  this.breed = breed;
}

// buddyを作成し吠え方(bark)を教える
var buddy = new Dog("golden Retriever");
Dog.prototype.bark = function() {
  console.log("Woof");
};
buddy.bark();

// snoopyを作成
var snoopy = new Dog("Beagle");
/// 今度は動く
snoopy.bark();
</pre>
			</div>
			</div> <!--/row-->
			
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>一般に、クラスのメンバーすべてが使えるメソッドをクラスに追加するには、
			右記のように記述しプロトタイプを拡張します。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
<span class="text-info">className</span>.prototype.<span class="text-info">newMethod</span> =function<span class="text-error">() {
statements;
}</span>;
</pre>
			</div>
			</div> <!--/row-->

			<hr class="bs-docs-separator">
			<h3 class="text-info">富を受け継ぐ</h3>
			
			<h4>すべては遺伝子に</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>OOPでは、<strong>継承</strong>は、あるクラスが他のクラスの
			プロパティを見たりメソッドを使えるようにします。</p>
			<p>まずは復習</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Animal class を作る
function Animal(name,numLegs){
	this.name = name;
	this.numLegs = numLegs;
}

// sayName method for Animal　を作る
Animal.prototype.sayName = function() {
	console.log("Hi my name is " + this.name);
};

// penguinオブジェクトを作り、メソッドを実行する
var penguin = new Animal("Captain Cook", 2);
penguin.sayName();
</pre>
			</div>
			</div> <!--/row-->


			<h4>ペンギンの行進</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>Animalクラスと同様なPenguinクラスを作ります。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Animal class を作る
function Animal(name,numLegs){
	this.name = name;
	this.numLegs = numLegs;
}

// sayName method for Animal　を作る
Animal.prototype.sayName = function() {
	console.log("Hi my name is " + this.name);
};

// Penguin class を作る
function Penguin(name,numLegs){
	this.name = name;
	this.numLegs = numLegs;
}

// sayName method for Penguin　を作る
Penguin.prototype.sayName = function() {
	console.log("Hi my name is " + this.name);
};

// penguinオブジェクトを作り、メソッドを実行
var penguin = new Penguin("Captain Cook", 2);
penguin.sayName();
</pre>
			</div>
			</div> <!--/row-->


			<h4>DRY ペンギン</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>前掲のコードでは、<code>Penguin</code>は<code>Animal</code>クラスの
			多くのコードを再度書いています。これはプログラミングの&quot;DRY&quot;principle
			(コードの重複記述を避ける)に反します。ここで<strong>継承</strong>が役に立ちます。</p>
			<p><code>Penguin</code>は<code>Animal</code>ですから、<code>Animal</code>として
			すべてのプロパティとメソッドを持たせるべきです。
			<strong>X is Y</strong>の関係がある場合は、継承を使ういいチャンスです。</p>
			<p><em>継承</em>は他のクラスのプロパティやメソッドを見たり使ったりさせます。
			<code>Penguin</code>に<code>Animal</code>を継承させましょう。それには
			<code>Penguin</code>の<span class="text-info">prototype</span>を
			<code>Animal</code>にします。</p>
			<p><code>Penguin</code>クラスを定義します。
			<code>Penguin</code>コンストラクタは元の<code>Animal</code>コンストラクタ
			に比べユニークです。ペンギンはすべて２本脚ですし、引数は<code>name</code>
			しかとりません。</p>
			<p><code>Penguin</code>に<code>Animal</code>から<em>継承</em>させましょう。</p>
			<p>
				<code>Penguin</code>.<span class="text-info">prototype</span>
	 			= <span class="text-warning">new</span> <code>Animal()</code>
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// the original Animal class and sayName method
function Animal(name, numLegs) {
    this.name = name;
    this.numLegs = numLegs;
}
Animal.prototype.sayName = function() {
    console.log("Hi my name is "+this.name);
};

// define a Penguin class
function Penguin(name){
	this.name = name;
	this.numLegs = 2;
}

// set its prototype to be a new instance of Animal
Penguin.prototype = new Animal();
penguin = new Penguin("Take");
penguin.sayName();
</pre>
			</div>
			</div> <!--/row-->


			<h4>ペンギン、プロパティ、プロトタイプ</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>Penguin</code>が、どのように<code>sayName</code>メソッドを
			<code>Animal</code>から継承するかをみました。
			今度はクラスがプロパティを継承するのを見てみましょう。</p>
			<p><code>Penguin</code>クラスを定義します。
			<code>Animal</code>から何も継承していません。
			</p>
			<p><code>Emperor</code>クラスを定義します。引数<code>name</code>を受け取り、
			プロパティ<code>name</code>にセットします。
			<code>numLegs</code>プロパティは、このコンストラクタの中ではセットしません。</p>
			<p><code>Emperor</code>は<code>Penguin</code>を継承します。</p>
			<p><code>emperor</code>オブジェクトを作成し、<code>numLegs</code>を表示します。
			このプロパティは<code>Penguin</code>から継承されたものです。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Penguin(name) {
    this.name = name;
    this.numLegs = 2;
}

// Emperor class を作成し Penguin classを継承します
function Emperor(name) {
	this.name = name;
}
Emperor.prototype = new Penguin();
// emperor オブジェクトを作成し number of legs を表示します。
var emperor = new Emperor("Kate");
console.log(emperor.numLegs);
</pre>
			</div>
			</div> <!--/row-->


			<h4>食べ物は上! プロトタイプ連鎖</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ペンギンは動物で、皇帝ペンギンはペンギンで、
			そして皇帝ペンギンは動物です。</p>
			<p>JavaScriptの&quot;プロトタイプ　チェーン&quot;は、このことをよく知っています。
			JavaScriptが今いるクラスのメソッドやプロパティに見つからないものがあると、
			継承したクラスの中に定義されているかどうか調べに、プロトタイプ　チェーンを
			上へと探っていきます。この探索は最上位の
			<span class="text-info">Object.prototype</span>で止まるまで続きます。</p>
			<p>既定では、すべてのクラスは直接<span class="text-info">Object</span>を
			継承しています、ただし<code>Penguin</code>や<code>Emperor</code>
			のようにクラスの<span class="text-info">prototype</span>を変更していなければ。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// original classes
function Animal(name, numLegs) {
    this.name = name;
    this.numLegs = numLegs;
    this.isAlive = true;
}
function Penguin(name) {
    this.name = name;
    this.numLegs = 2;
}
function Emperor(name) {
    this.name = name;
    this.saying = "Waddle waddle";
}

// set up the prototype chain 
// Animal -> Penguin -> Emperor
Penguin.prototype = new Animal();
Emperor.prototype = new Penguin();

var myEmperor = new Emperor("Jules");

console.log( myEmperor.saying ); // should print "Waddle waddle"
console.log( myEmperor.numLegs ); // should print 2
console.log( myEmperor.isAlive ); // should print true
</pre>
			</div>
			</div> <!--/row-->


			<hr class="bs-docs-separator">
			<h3 class="text-info">プライバシーでお願い</h3>
			
			<h4>公開する</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>JavaScriptでは、オブジェクトのすべてのプロパティは自動的にパブリックになります。
			<strong>パブリック</strong>とは、そのクラスの外部からアクセスできることです。
			このプロパティは、クラスが共有したい情報として考えられます。</p>
			<p><code>Person</code>クラスには、パブリックなプロパティの
			<code>firstName</code>, <code>lastName</code>, <code>age</code>
			があります。</p>
			<p><code>john</code>のプロパティ<code>firstName</code>,<code>LastName</code>
			,<code>age</code>にアクセスして、
			<code>myFirst</code>,<code>myLast</code>,<code>myAge</code>に設定しています。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(first,last,age) {
   this.firstName = first;
   this.lastName = last;
   this.age = age;
}

var john = new Person('John','Smith',30);
var myFirst = john.firstName;
var myLast = john.lastName;
var myAge = john.age;
</pre>
			</div>
			</div> <!--/row-->


			<h4>プライベート変数</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトが情報のいくつかを隠したい場合はどうするか？</p>
			<p>関数が、その関数の中からのみアクセスできるローカル変数を持てるように、
			オブジェクトはプライベート変数を持てます。
			<strong>プライベート</strong>変数は、共有したくない情報であり、
			そのクラスの中からだけ直接アクセスできるものです。</p>
			<p><code>Person</code>クラスを変更して、
			プライベート変数<code>bankBalance</code>を追加します。
			普通の変数のように見えますが、
			<code>Person</code>コンストラクタの中に定義されていて、
			<code>this</code>の代わりに <code>var</code>が使われています。</p>
			<p>これで<code>bankBalance</code>はプライベート変数になります。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
}

// create your Person 
var john = new Person("Kate","John",33);

// try to print his bankBalance
// should print "undefined"
console.log(john.bankBalance); 
</pre>
			</div>
			</div> <!--/row-->



			<h4>プライベート変数を扱う</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>プライベート変数に、そのクラスの外から直接アクセスできませんが、方法があります。
			プライベート変数の値を返すパブリック・メソッドを定義することができます。</p>
			<p><code>bankBalance</code>を返す<code>getBalance</code>メソッドを
			<code>Person</code>クラスに追加しています。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
  
   this.getBalance = function() {
      // your code should return the bankBalance
      return bankBalance;
   };
}

var john = new Person('John','Smith',30);
// should print "undefined"
console.log(john.bankBalance);

/* create a new variable myBalance 
               that calls getBalance() */
var myBalance = john.getBalance();
console.log(myBalance); // should print 7500
</pre>
			</div>
			</div> <!--/row-->




			<h4>プライベートメソッド</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>メソッドも、クラスの外からアクセスできないプライベートにすることができます。</p>
			<p>前項の
			<span class="text-info">this.</span><span class="text-error">getBalance</span>を
			<span class="text-info">var </span><span class="text-error">getBalance</span>に
			変更すると、このメソッドはプライベートになります。これだけではまだ駄目です。
			</p>
			<p>プライベート　メソッドにアクセスする方法は、プライベート変数にアクセスする
			のと似ています。そのクラスにプライベート　メソッドを返す、パブリック　メソッド
			<span class="text-info">this.</span><span class="text-error">askTeller</span>
			を作成します。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
  
   // private method
   var getBalance = function() {
      return bankBalance;
   };
       
   // public method
   this.askTeller = function() {	
   return getBalance();
   };
}

var john = new Person('John','Smith',30);
// print "undefined" error
console.log(john.getBalance);  
// puplic method -> private method
var myBalanceMethod = john.askTeller(); 
var myBalance = myBalanceMethod;
console.log(myBalance); // print 7500

</pre>
			</div>
			</div> <!--/row-->



			<h4>引数を受け渡す</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>Person</code>クラス内の<code>askTeller</code>関数を修正し
			直接口座情報を返すようにしてあります、
			しかし、<code>bankBalance</code>を返すには、引数としてパスワードを
			必要としています。
			</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function Person(first,last,age) {
   this.firstname = first;
   this.lastname = last;
   this.age = age;
   var bankBalance = 7500;
  
  // public method
   this.askTeller = function(pass) {
     if (pass == 1234) return bankBalance;
     else return "Wrong password.";
   };
}

var john = new Person('John','Smith',30);
//パスワードを引数にしてaskTellerにアクセス
var myBalance = john.askTeller("1234");
</pre>
			</div>
			</div> <!--/row-->

        </section>



        <hr class="bs-docs-separator">
        <!-- Loops
        ================================================== -->
        <section id="loops">
          <div class="page-header">
            <h1>Loops</h1>
          </div>

			<p class="lead">
				ループは、"for" や "while" を含め、条件が合うまで一連の命令を繰り返す
			</p>

			<!------------------------------------------------->
			<h3 class="text-info">Counting With Loops </h3>
			<h4>One to Five</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
				<p>
				<code>for</code>ループは
				<span class="text-success">console.log</span>
				<span class="text-error">(i)</span>を何度も実行します。
				変数<code>i</code>の値を変えることで、何回コードを実行するかを追跡しています。
				</p>
				<p>
				ループ変数は、変数<code>i</code>の変え方を示しています。
				</p>
				<ul>
					<li><code>i = 5</code>- 最初の値</li>
					<li><code>i &lt;= 5</code>- 止めるとき</li>
					<li><code>i++</code>  - コード実行後にカウントアップ</li>
				</ul>
				<p>ループ内のコードは変数<code>i</code>を読むことができます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i;

for (i = 1; i <= 5; i++) {
    console.log(i);
}
</pre>
			</div>
			</div>


			<h4>Counting by Twos</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
				<p><code>i++</code>は、<code>i</code>を１増します。
				では１より多くを増やすにはこれを使います。
				</p>
				<p><code>i += number</code></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i;

for (i = 2; i <= 6; i += 2) {
    console.log(i);
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Countdown</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>for</code>ループは、カウントを増やすだけでなく減らすこともできます。
			変数<code>i</code>の初期値を大きくして、それを小さくしながらループさせます。</p>
			<p>カウントを減らすには<code>i--</code>や<code>i -= number</code>を
			使います。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i;

for (i=5 ;i>=0 ;i-- ) {
    console.log(i);
}
</pre>
			</div>
			</div><!-- /row -->


			<hr class="bs-docs-separator">
			<!------------------------------------------------->
			<h3 class="text-info">Looping in Arrays and Strings </h3>

			<h4>Looping Through Arrays</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ループをカウントして使えました。そしてループを使って
			配列のすべての要素を扱うこともできます。</p>
			<p>配列の各要素は位置番号(index：指標)を持っています。
			まず、配列の全要素に渡り繰返すことは、配列の全指標に渡り繰返すことです。
			配列の指標は 0 から始まり、
			配列の大きさ(<code>array.length</code>)引く１で終わります。</p>
			<p>配列の指標番号(index number)がわかれば、
			対応する配列要素(<code>array[indexNumber]</code>)を取得できます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i;
var animals = ["cat", "dog", "ferret"];

// Loop goes here
for (i=0;i&lt;=animals.length-1;i++){
	console.log(animals[i]);
}
</pre>
			</div>
			</div><!-- /row -->

			<h4>Better, Stronger, Faster</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>コードはより早く動くほうがいいです。
			学習中のコードは、十分に早いとは言えません。</p>
			<p>環境によって、<code>array.length</code>を読むプロセスは少し遅くなります。</p>
			<p><code>for</code>ループの２番目、３番目のパラメータは、繰返し毎に評価されます。
			その為、配列の要素が多い場合には時間がかかるかもしれません。</p>
			<div class="row">
<prespan3">
var length = animals.length;
</pre>
			</div>
			を追加し、式の評価を一度だけにします。
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i;
var animals = ["cat", "dog", "ferret"];
var length = animals.length;
// Loop goes here
for (i=0;i&lt;=length-1;i++){
	console.log(animals[i]);
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Looping Through Strings</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>文字列は、基本的に文字の配列です。配列の要素を扱うのと同様な方法で
			文字列の個々の文字を取得することができます。
			<code>string[indexNumber]</code></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var word = "code";
var i = 0;
// Loop goes here
for (i=0;i&lt;word.length;i++){
	console.log(word[i]);
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Building substring (Part 1)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>substringはJavaScriptの関数です。文字列の一部を開始位置から終了位置
			まで抜き取ります。この関数を<code>for</code>ループで作ってみます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// Define substring here
var substring = function(input,start,end){
	var i = 0;
	for(i=start;i&lt;=end;i++){
		console.log(input[i]);
	}
};

substring("lorem ipsum dolor",6,10);
</pre>
			</div>
			</div><!-- /row -->


			<h4>Building substring (Part 2)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>正しい文字を抜き取れたので、抜き取った文字を繋いで１つの文字列を作り、
			呼び出し元へ返しましょう。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// 空の文字列変数を用意する
var subset = "";
// substring を定義する
var substring = function(input,start,end){
	var i = 0;
	for(i=start;i&lt;=end;i++){
		//文字を繋げる
		subset += input[i];
	}
	// 結果の文字列を返す
	return subset;
};
console.log(substring("lorem ipsum dolor",6,10));
</pre>
			</div>
			</div><!-- /row -->



			<hr class="bs-docs-separator">
			<!------------------------------------------------->
			<h3 class="text-info">While Loops </h3>


			<h4>Conditions!</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>while</code>ループは、条件が真の間、繰り返します。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var condition = true;
while (condition) {
    console.log("I only print once!");
    break;
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Imitation is the Sincerest Form of Flattery</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>while</code>ループはかなり柔軟です。
			<code>for</code>ループで出来ることは、できます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i = 1;
while(i &lt;= 5){
	console.log(i);
	i++;
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Counting Odd Numbers, Again</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>while</code>ループでも<code>i</code>に２を加えることができます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i = 1;
while(i &lt;= 5){
	console.log(i);
	i += 2;
}
</pre>
			</div>
			</div><!-- /row -->

			<h4>Splitting Name (Part 1)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>while</code>ループは、コードで何かを探さなければならない時に、
			それがどの位置にあるかわからない場合、特に役に立ちます。</p>
			<p>名前の文字列を分割してファーストネームを取出す関数を作っていきます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// 関数を定義
var getFirstName = function(fullName){
	// index変数を定義
	var i = 0;
	// 文字列長の変数を定義
	var length = fullName.length;
	// 繰り返し処理
	while(i&lt;length){
		// １文字出力
		console.log(fullName[i]);
		i++;
	}
} ;

getFirstName("Take Koyan");
</pre>
			</div>
			</div><!-- /row -->
			
			
			<h4>Splitting Name (Part 2)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>while</code>ループの条件は柔軟です。今回は２つの条件を
			&quot;&&&quot;で組合せます。
			ループの終了条件は、文字列が終わったか、空白があった時です。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// 関数を定義
var getFirstName = function(fullName){
	// 次の文字を保持する変数（先頭の文字を設定）
	var next = fullName[0];
	// index変数
	var i = 0;
	// 文字列長の変数
	var length = fullName.length;
	// 繰り返し
	while(i&lt;length && next !==" "){
		// 文字出力
		console.log(fullName[i]);
		// indexのインクリメント
		i++;
		// 次の文字を代入
		next = fullName[i];
	}
} ;

getFirstName("Take Koyan");
</pre>
			</div>
			</div><!-- /row -->


			<h4>Splitting Name (Part 3)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>個々の文字を１つの文字列に繋げて、呼び出し元へ返しましょう。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
// 抜取った文字を格納する変数
var firstName = "";
// 関数定義
var getFirstName = function(fullName){
	var next = fullName[0];
	var i = 0;
	var length = fullName.length;
	while(i&lt;length && next !==" "){
		// 文字列を繋げる
		firstName += fullName[i];
		i++;
		next = fullName[i];
	}
	// 文字列を返す
	return firstName;
} ;

console.log(getFirstName("Take Koyan"));
</pre>
			</div>
			</div><!-- /row -->


			<hr class="bs-docs-separator">
			<!------------------------------------------------->
			<h3 class="text-info">Recursion </h3>

			<h4>Counting Up With Recursion</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>関数の終了する理由に出会うまで、その関数自身を
			繰り返し呼ぶことで、<code>while</code>ループを
			まねることができます。右の<code>countUp</code>は
			このトリックを使って５まで数えています。</p>
			<p>この方法（再帰呼出）でループを作る時のことを考えましょう。</p>
			<p>繰返し中の各ステップでどんな動作が起きているのでしょう、
			そして最後は？。関数は各ステップである動作（<code>countUp</code>は数字を表示する。）
			をし、自分自身を呼ぶことで、繰り返しの次のステップへと続けます。
			これを<strong>recursive case</strong>と呼びます。</p>
			<p>繰り返しの最終ステップでは、関数はその動作を行い、そして終了します。
			自分自身を呼ばないことで、繰り返しを終了します。
			これを<strong>base case</strong>と呼びます。</p>
			<p>データがどのように次のステップへと受け渡されるのか？
			再帰関数では、引数を使います。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function countUp(current) {
    // Recursive case
    if (current < 5) {
        console.log(current);
        
        /* countUpを呼び、引数でもって情報を 
         受け渡すことで繰り返しを続けます。
         `current + 1` は `for` loopの`i++` 
        にあたります。*/
        countUp(current + 1);
    }
    
    // Base case
    if (current === 5){
        console.log(current);
        
        /* 最終ステップ。ここから"countUp" を
         呼ばないことで繰り返しをやめます。*/
    }
}

// 関数を呼ぶことで繰り返しを開始します。
countUp(1);
</pre>
			</div>
			</div><!-- /row -->


			<h4>Counting Down With Recursion</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>for</code>ループでは、カウントダウンすることができました。
			再帰関数でも同じことができます。</p>
			<p><code>current</code>が１より大きいとき自分自身を呼び出し繰り返します。
			受け渡す値は<code>current-1</code>です。</p>
			<p>繰り返しの終了は、<code>current</code>が５になった時です。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
function countDown(current) {
    // Recursive case
    if (current > 1) {
        console.log(current);
        
       countDown(current - 1);
    }
    // Base case
    if (current === 1){
        console.log(current);
    }
}
countDown(5);
</pre>
			</div>
			</div><!-- /row -->

			<h4>Building 'substring' With Recurshon (Part 1)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>再帰呼び出しを使うことで、<code>for</code>ループより
			もっと簡単に<code>substring</code>を作ることができます。</p>
			<p>今回作成する関数は３つの引数を取ります。
			<code>all</code>:文字列全体
			<code>start</code>:切り取る最初の文字位置
			<code>end</code>:切り取る最後の文字位置</p>
			<p>今回の作成プランは、<code>all</code>から１文字づつ抜き取り、
			<code>start</code>を１づつ増加させていきます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var substring = function(all,start,end){

	console.log(all[start]);

// base case
	if (start>=end){
	}
};
</pre>
			</div>
			</div><!-- /row -->

			<h4>Building 'substring' With Recurshon (Part 2)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p><code>else</code>文を追加し<strong>recursive case</strong>を書く。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var substring = function(all,start,end){
// base case
	if (start>=end){
	console.log(all[start]);
	} else {
// recursive case
		console.log(all[start]);
		substring(all,start+1,end);
	}
};
substring("lorem ipsum dolor",6,10);
</pre>
			</div>
			</div><!-- /row -->
			
			
			<h4>Building 'substring' With Recurshon (Part 3)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ループを基にした<code>substring</code>では、
			文字列に選択した１文字を付け加えていました。</p>
			<p>ですがここではできません。
			もし関数の外側に定義した文字列変数があれば、誰でも変更できます。
			その変数が関数の中に定義されていたとしても、
			<code>substring</code>から再帰呼出しされた<code>substring</code>では
			この変数にアクセスできません。しかしこのことを文字列変数なしに
			行わなくてはなりません。</p>
			<p>そこで,<code>return</code>文を使い、この処理のために文字を送ります。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var substring = function(all,start,end){

// base case
  if (start>=end){
    return all[start];
  } else {
    return all[start] + substring(all,start+1,end);
  }
};
console.log(substring("lorem ipsum dolor",6,10));
</pre>
			</div>
			</div><!-- /row -->

			<hr class="bs-docs-separator">
			<!------------------------------------------------->
			<h3 class="text-info">Extra Tricks </h3>


			<h4>Looping Through Objects</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>オブジェクトの中の情報すべてを表示するには、どうすればよいでしょう？</p>
			<p>配列では、繰り返し処理で指標を使いすべての要素名を取得できました。
			オブジェクトの場合も似ています。指標ではなくプロパティ名を持ち、
			つまり"keys"を持っています。</p>
			<p>特別な<code>for</code>ループを使って、オブジェクト内の
			すべてのキーを順番に処理します。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var person = {
    name: "Morgan Jones",
    telephone: "(650) 777 - 7777",
    email: "morgan.jones@example.com"
};

for (var propertyName in person) {
    console.log(propertyName + ": " + person[propertyName]);
}
</pre>
			</div>
			</div><!-- /row -->
			

			<h4>Nesting 'for' Loops</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ループの入れ子に制限はありません。
			<code>for</code>ループの中に<code>while</code>ループ、
			<code>for</code>ループの中に<code>for</code>ループ、などなど。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var i = 0;
var j = 0;
for (i=1;i<=3;i++){
	for (j=1;j<=5;j++){
		console.log(j);
	}
}
</pre>
			</div>
			</div><!-- /row -->


			<h4>Printing Out Tables (Part 1)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ここでの小技は、配列の中に配列を置くというものです。</p>
			<p>右のコードでは、この技を使って
			スプレッドシートのテーブルのようなデータ形式を表現しています。
			配列<code>table</code>は、内部に複数の配列を持っています。
			中の配列それぞれは行を表します。各配列の要素はセル表します。</p>
			<p>入れ子のループを使って、<code>table</code>の各要素にアクセスします。</p>
			<p>変数<code>rows</code>を定義して、<code>table</code>の大きさをセットします。
			変数<code>r</code>は、<code>for</code>ループの繰り返しに使用します。
			まずは変数<code>r</code>を表示してみます。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var table = [
    ["Person",  "Age",  "City"],
    ["Sue",     22,     "San Francisco"],
    ["Joe",     45,     "Halifax"]
];

var rows = table.length;
var r;
for(r=0;r&lt;rows;r++){
	console.log(r);
}
</pre>
			</div>
			</div><!-- /row -->

			<h4>Printing Out Tables (Part 2)</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
var table = [
    ["Person",  "Age",  "City"],
    ["Sue",     22,     "San Francisco"],
    ["Joe",     45,     "Halifax"]
];

var rows = table.length;
var r;
for(r=0;r&lt;rows;r++){
	var c;
	var cells = table[r].length;
	var rowText = "";
	for(c=0;c&lt;cells;c++){
		rowText += table[r][c];
		if(c&lt;cells){
			rowText += "  ";
		}
	}

	console.log(rowText);
}
</pre>
			</div>
			</div><!-- /row -->
			
			
			<h4>Breaking Out</h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p>ループをある条件で、即座に終了したいときに
			<code>break</code>文が使えます。
			<code>for,while</code>両方で使えますが、再帰呼出では使えません。</p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
while (true) {
    console.log("I only print once!");
    break;
}
</pre>
			</div>
			</div><!-- /row -->



        </section>


		<hr class="bs-docs-separator">
        <!-- xxxxxxxxx
        ================================================== -->
        <section id="xxxxxxx">
          <div class="page-header">
            <h1>Conditional</h1>
          </div>

			<p class="lead">
				条件式
			</p>

			<h4></h4>
			<div class="row">
			<div class="col-sm-5 col-md-5">
			<p></p>
			</div>
			<div class="col-sm-5 col-md-5">
<pre>
</pre>
			</div>
			</div><!-- /row -->

        </section>


      </div>
    </div>

  </div>


      <footer>
        <p>&copy; koyamatc@koyamatch.com 2012</p>
      </footer>

    </div><!--/.fluid-container-->

	<script src="../js/jquery.js"></script>
	<script src="../assets/googlecodeprettify/prettify.js"></script>
  <script src="../js/bootstrap.js"></script>
  <script src="tw_popover.js"></script>
  <script src="tw_modal.js"></script>
   
  <script src="../js/application.js"></script>
  
</body>

</html>
